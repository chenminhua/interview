## 为什么 mv 比 cp 快

当不更换文件系统时，对文件进行重命名（比如 mv）,只需要构造一个新的符号链接，并将老的符号链接删掉就行（这就是为啥 mv 比 cp 快）。

## 为什么删除文件的系统调用叫 unlink

我们可以把一个磁盘分成一个或多个分区，每个分区一个文件系统。i 节点是固定长度的记录项，其中记录有关文件的大部分信息。可以有多个文件指向同一个 i 节点，每个 i 节点都有一个链接计数，只有当链接计数为 0 时，才可以删除文件（释放文件占用的数据块）。这也是为什么删除一个文件的函数被称为 unlink 而不是 delete 的原因。

每个目录都有一个本身的链接，一个.链接，如果其还有子目录，则每个子目录都会有一个..链接指向这个父目录。（这就是为啥不能直接删除目录）

## 如果两个进程同时打开同一个文件，并且开始写，会发生什么?

假如你没有使用 O_APPEND 选项打开文件，此时每个进程都有一个文件表项，但是共享一个 v 节点表项。假设现在文件有 1500 字节，此时 A 进程调用了 lseek，将进程 A 的该文件当前偏移量设置为 1500 字节。然后内核切换进程，进程 B 也将偏移量设置在 1500 字节处，B 向文件写入 100 字节，所以偏移量来到了 1600。此时进程再次切换回了 A，A 不知道偏移量来到了 1600，因此它开始从 1500 位置写，就覆盖了 B 写的东西。
问题出在先定位到文件末尾在写，这是两个分开的系统调用。解决这个问题的方法是将这两个操作合并成一个原子操作。只需要在打开文件时使用 O_APPEND 选项即可。

## 有没有什么调用是调用一次返回两次的

fork 函数调用一次但是返回两次。区别是子进程的返回值为 0，而父进程的返回值为新建子进程的 pid。一般来说 fork 之后先执行父进程还是子进程是不确定的，这取决于内核的调度算法。父子进程分别继续执行 fork 之后的指令，子进程获得父进程数据空间和堆栈副本。注意，子进程获得的是副本，他们并不共享这些存储空间（只共享正文段）。

## 如何避免出现僵死进程

先生个儿子，儿子生个孙子。然后杀了儿子，让孙子去做 init 的儿子。

## 当你按下 ctrl + c 发生了什么

## linux 中每个 tcp 连接最少占用多少内存？

每个 TCP socket 占用的内存最少是 256 + 192 + 640 + 1792 + 64 = 2944 字节。后面的实验表明，实际占用的字节数会比这个略大，原因有三点。创建 10000 个 TCP socket 会使用 31552 KB 内存（通过比较 /proc/meminfo 得出），即每个 TCP socket 占用 3.155 KB，这个数字很接近上面考虑 SLAB overhead 之后的计算结果。
